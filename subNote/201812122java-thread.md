# [目录](../directory.md)
#### 说明  
多线程使用
---

#### 参考文献  
* [Java多线程学习(总结很详细)](https://www.cnblogs.com/yjd_hycf_space/p/7526608.html) 
* [Java多线程系列目录(共43篇)](https://www.cnblogs.com/skywang12345/p/java_threads_category.html)
* [java常用的几种线程池比较](https://www.cnblogs.com/aaron911/p/6213808.html)
 
---
#### 学习笔记
* 进程和线程 
>进程：每个进程都有独立的代码和数据空间（进程上下文），进程间的切换会有较大的开销，一个进程包含1--n个线程。（进程是资源分配的最小单位）  
 线程：同一类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器(PC)，线程切换开销小。（线程是cpu调度的最小单位）  
 线程和进程一样分为五个阶段：创建、就绪、运行、阻塞、终止。  
 多进程是指操作系统能同时运行多个任务（程序）。  
 
* 线程状态转换  
>![图示](../img/2018-12-20-1)  
1、新建状态（New）：新创建了一个线程对象。  
2、就绪状态（Runnable）：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于可运行线程池中，变得可运行，等待获取CPU的使用权。  
3、运行状态（Running）：就绪状态的线程获取了CPU，执行程序代码。  
4、阻塞状态（Blocked）：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：  
（一）、等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。(wait会释放持有的锁)  
（二）、同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。  
（三）、其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态    
5、死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。    

* 线程调度   
>1、调整线程优先级：Java线程有优先级，优先级高的线程会获得较多的运行机会。  
 Java线程的优先级用整数表示，取值范围是1~10，Thread类有以下三个静态常量：  
 static int MAX_PRIORITY  
          线程可以具有的最高优先级，取值为10。  
 static int MIN_PRIORITY  
          线程可以具有的最低优先级，取值为1。  
 static int NORM_PRIORITY  
          分配给线程的默认优先级，取值为5。  
 Thread类的setPriority()和getPriority()方法分别用来设置和获取线程的优先级。  
 每个线程都有默认的优先级。主线程的默认优先级为Thread.NORM_PRIORITY。  
 线程的优先级有继承关系，比如A线程中创建了B线程，那么B将和A具有相同的优先级。  
 JVM提供了10个线程优先级，但与常见的操作系统都不能很好的映射。如果希望程序能移植到各个操作系统中，应该仅仅使用Thread类有以下三个静态常量作为优先级，这样能保证同样的优先级采用了同样的调度方式。  
 2、线程睡眠：Thread.sleep(long millis)方法，使线程转到阻塞状态。millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。sleep()平台移植性好。  
 3、线程等待：Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法。这个两个唤醒方法也是Object类中的方法，行为等价于调用 wait(0) 一样  
[(wait和notify这两个方法是一对，wait方法阻塞当前线程，而notify是唤醒被wait方法阻塞的线程)](https://www.cnblogs.com/ismallboy/p/6785312.html)。  
 4、线程让步：Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。  
 5、线程加入：join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。  
 6、线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。  
 选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。  
 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。 
 被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；  
 例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程。  
 注意：Thread中suspend()和resume()两个方法在JDK1.5中已经废除，不再介绍。因为有死锁倾向。  
 
 * 常见名词    
 >主线程：JVM调用程序main()所产生的线程。  
  当前线程：这个是容易混淆的概念。一般指通过Thread.currentThread()来获取的进程。  
  后台线程：指为其他线程提供服务的线程，也称为守护线程。JVM的垃圾回收线程就是一个后台线程。用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束  
  前台线程：是指接受后台线程服务的线程，其实前台后台线程是联系在一起，就像傀儡和幕后操纵者一样的关系。傀儡是前台线程、幕后操纵者是后台线程。由前台线程创建的线程默认也是前台线程。可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程。  
  线程类的一些常用方法：   
  sleep(): 强迫一个线程睡眠Ｎ毫秒。   
  isAlive(): 判断一个线程是否存活。   
  join(): 等待线程终止。   
  activeCount(): 程序中活跃的线程数。   
  enumerate(): 枚举程序中的线程。   
  currentThread(): 得到当前线程。   
  isDaemon(): 一个线程是否为守护线程。   
  setDaemon(): 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束)   
  setName(): 为线程设置一个名称。   
  wait(): 强迫一个线程等待。   
  notify(): 通知一个线程继续运行。   
  setPriority(): 设置一个线程的优先级。  